define

    piece sub entity,
    plays mover,
    plays positioned,
    has colour;

    colour sub attribute,
    value string;

    king sub piece;

    # test piece with very limited f  unctionality
    lameRook sub piece;

    rook sub piece;
    bishop sub piece;
    queen sub piece;
    pawn sub piece;
    knight sub piece;

    direction sub entity,
    has colour,
    plays adj-direction,
    plays trav-direction,
    plays base-dir,
    plays inferred-dir;

    cross sub direction;

    diagangle sub direction;

    square sub entity,
    plays origin,
    plays destination,
    plays start-square,
    plays end-square,
    plays position,
    plays start-node,
    plays end-node,
    has coor;
    # has xPos,
    # has yPos;

    coor sub attribute,
    value string;

    board sub entity;


    potential-move sub relation,
    relates mover,
    relates origin,
    relates destination;

    adjacency sub relation,
    relates adj-direction,
    relates start-square,
    relates end-square;



    legal-move sub potential-move,
    relates mover,
    relates origin,
    relates destination;    

    positioning sub relation,
    relates positioned,
    relates position;

    traversal sub relation,
    relates trav-direction,
    relates start-node,
    relates end-node;

    trans-traversal sub traversal,
    relates trav-direction,
    relates start-node,
    relates end-node;
    
    single-traversal sub traversal,
    relates trav-direction,
    relates start-node,
    relates end-node;

    L-traversal sub traversal,
    relates trav-direction,
    relates start-node,
    relates end-node;

    dir-creation sub relation,
    relates base-dir,
    relates inferred-dir;

    adjacency-creation-rule sub rule,
    when {
        (base-dir: $b1, base-dir: $b2, inferred-dir: $i) isa dir-creation;
        (start-square: $a, end-square: $b, adj-direction: $b1) isa adjacency;   
        (start-square: $a, end-square: $c, adj-direction: $b2) isa adjacency;
        (start-square: $b, end-square: $d, adj-direction: $b2) isa adjacency;
        (start-square: $c, end-square: $d, adj-direction: $b1) isa adjacency;
    }, then {
        (start-square: $a, end-square: $d, adj-direction: $i) isa adjacency;
    };

    # not used, but has potential
    # direction-colouring-rule sub rule,
    # when {
    #     $b1 has colour $col;
    #     (base-dir: $b1, base-dir: $b2, inferred-dir: $i) isa dir-creation;
    #     (start-square: $a, end-square: $b, adj-direction: $b1) isa adjacency;   
    #     (start-square: $a, end-square: $c, adj-direction: $b2) isa adjacency;
    #     (start-square: $b, end-square: $d, adj-direction: $b2) isa adjacency;
    #     (start-square: $c, end-square: $d, adj-direction: $b1) isa adjacency;
    # }, then {
    #     $b1 has colour $col;
    # };

    # adj-symmetry sub rule,
    # when {
    #     $dir isa direction;
    #     not {$dir has colour $col;};
    #     (start-square: $a, end-square: $b, adj-direction: $dir) isa adjacency;
    # }, then {
    #     (start-square: $b, end-square: $a, adj-direction: $dir) isa adjacency;
    # };

    single-traversal-rule sub rule,
    when {
        (start-square: $a, end-square: $b, adj-direction: $dir) isa adjacency;
    }, then {
        (start-node: $a, end-node: $b, trav-direction: $dir) isa single-traversal;
    };

    trans-traversal-rule sub rule,
    when {
        (start-square: $a, end-square: $b, adj-direction: $dir) isa adjacency;
    }, then {
        (start-node: $a, end-node: $b, trav-direction: $dir) isa trans-traversal;
    };

    L-traversal-rule sub rule,
    when {
        $dir1 isa cross;
        $dir2 isa cross;
        $dir1 != $dir2;
        (start-square: $a, end-square: $b, adj-direction: $dir1) isa adjacency;
        (start-square: $b, end-square: $c, adj-direction: $dir1) isa adjacency;
        $a != $c;
        (start-square: $c, end-square: $d, adj-direction: $dir2) isa adjacency;
        $d != $b;
    }, then {
        (start-node: $a, end-node: $d) isa L-traversal;
    };

    transitivity sub rule,
    when {
        (start-node: $a, end-node: $b, trav-direction: $dir) isa trans-traversal;
        not {(position: $b) isa positioning;}; # implement blocking
        (start-node: $b, end-node: $c, trav-direction: $dir) isa trans-traversal;
        $a != $c;
    }, then {
        (start-node: $a, end-node: $c, trav-direction: $dir) isa trans-traversal;
    };

    rook-move sub rule,
    when {
        $r isa rook;
        $dir isa cross;
        (positioned: $r, position: $a) isa positioning;
        (start-node: $a, end-node: $b, trav-direction: $dir) isa trans-traversal;
    }, then {
        (mover: $r, origin: $a, destination: $b) isa potential-move;
    };

    bishop-move sub rule,
    when {
        $e isa bishop;
        $dir isa diagangle;
        (positioned: $e, position: $a) isa positioning;
        (start-node: $a, end-node: $b, trav-direction: $dir) isa trans-traversal;
    }, then {
        (mover: $e, origin: $a, destination: $b) isa potential-move;
    };

    queen-move sub rule,
    when {
        $q isa queen;
        (positioned: $q, position: $a) isa positioning;
        (start-node: $a, end-node: $b) isa trans-traversal;
    }, then {
        (mover: $q, origin: $a, destination: $b) isa potential-move;
    };

    king-move sub rule,
    when {
        $k isa king;
        (positioned: $k, position: $a) isa positioning;
        (start-node: $a, end-node: $b) isa single-traversal;
    }, then {
        (mover: $k, origin: $a, destination: $b) isa potential-move;
    };

    pawn-move sub rule,
    when {
        $p isa pawn, has colour $col;
        $dir isa cross, has colour $col; # allows more whacky chess, ^.^
        (positioned: $p, position: $a) isa positioning;
        (start-node: $a, end-node: $b, trav-direction: $dir) isa single-traversal;
        not {(position: $b) isa positioning;};
    }, then {
        (mover: $p, origin: $a, destination: $b) isa potential-move;
    };

    pawn-take sub rule,
    when {
        $p isa pawn, has colour $col;
        $dir isa diagangle, has colour $col;
        (positioned: $p, position: $a) isa positioning;
        (start-node: $a, end-node: $b, trav-direction: $dir) isa single-traversal;
        $pc isa piece, has colour $col2;
        (positioned: $pc, position: $b) isa positioning;
        $col != $col2;
    }, then {
        (mover: $p, origin: $a, destination: $b) isa potential-move;
    };

    knight-move sub rule,
    when {
        $k isa knight;
        (positioned: $k, position: $a) isa positioning;
        (start-node: $a, end-node: $b) isa L-traversal;
    }, then {
        (mover: $k, origin: $a, destination: $b) isa potential-move;
    };

    # can always move to an empty space
    empty-rule sub rule,
    when {
        (mover: $p, origin: $a, destination: $b) isa potential-move;
        not {(position: $b) isa positioning;};
    }, then {
        (mover: $p, origin: $a, destination: $b) isa legal-move;
    };

    take-rule sub rule,
    when {
        $p isa piece, has colour $col1;
        (mover: $p, origin: $a, destination: $b) isa potential-move;
        (positioned: $t, position: $b) isa positioning;
        $t has colour $col2;
        $col1 != $col2;
    }, then {
        (mover: $p, origin: $a, destination: $b) isa legal-move;
    };

    # DATA
    # 4x4 grid

insert 

    $sa1 isa square, has coor "A1";
    $sa2 isa square, has coor "A2";
    $sa3 isa square, has coor "A3";
    $sa4 isa square, has coor "A4";
    $sb1 isa square, has coor "B1";
    $sb2 isa square, has coor "B2";
    $sb3 isa square, has coor "B3";
    $sb4 isa square, has coor "B4";
    $sc1 isa square, has coor "C1";
    $sc2 isa square, has coor "C2";
    $sc3 isa square, has coor "C3";
    $sc4 isa square, has coor "C4";
    $sd1 isa square, has coor "D1";
    $sd2 isa square, has coor "D2";
    $sd3 isa square, has coor "D3";
    $sd4 isa square, has coor "D4";

    $fromWhite isa cross, has colour "white";
    $fromBlack isa cross, has colour "black";
    $left isa cross;
    $right isa cross;
    # $horizontal isa cross;
    $nwDiag isa diagangle, has colour "white";
    $neDiag isa diagangle, has colour "white";
    $swDiag isa diagangle, has colour "black";
    $seDiag isa diagangle, has colour "black";

    (base-dir: $left, base-dir: $fromWhite, inferred-dir: $nwDiag) isa dir-creation;
    (base-dir: $left, base-dir: $fromBlack, inferred-dir: $swDiag) isa dir-creation;
    (base-dir: $right, base-dir: $fromWhite, inferred-dir: $neDiag) isa dir-creation;
    (base-dir: $right, base-dir: $fromBlack, inferred-dir: $seDiag) isa dir-creation;

    (start-square: $sa1, end-square: $sa2, adj-direction: $fromWhite) isa adjacency;
    (start-square: $sa2, end-square: $sa3, adj-direction: $fromWhite) isa adjacency;
    (start-square: $sa3, end-square: $sa4, adj-direction: $fromWhite) isa adjacency;
    (start-square: $sb1, end-square: $sb2, adj-direction: $fromWhite) isa adjacency;
    (start-square: $sb2, end-square: $sb3, adj-direction: $fromWhite) isa adjacency;
    (start-square: $sb3, end-square: $sb4, adj-direction: $fromWhite) isa adjacency;
    (start-square: $sc1, end-square: $sc2, adj-direction: $fromWhite) isa adjacency;
    (start-square: $sc2, end-square: $sc3, adj-direction: $fromWhite) isa adjacency;
    (start-square: $sc3, end-square: $sc4, adj-direction: $fromWhite) isa adjacency;
    (start-square: $sd1, end-square: $sd2, adj-direction: $fromWhite) isa adjacency;
    (start-square: $sd2, end-square: $sd3, adj-direction: $fromWhite) isa adjacency;
    (start-square: $sd3, end-square: $sd4, adj-direction: $fromWhite) isa adjacency;

    (start-square: $sa2, end-square: $sa1, adj-direction: $fromBlack) isa adjacency;
    (start-square: $sa3, end-square: $sa2, adj-direction: $fromBlack) isa adjacency;
    (start-square: $sa4, end-square: $sa3, adj-direction: $fromBlack) isa adjacency;
    (start-square: $sb2, end-square: $sb1, adj-direction: $fromBlack) isa adjacency;
    (start-square: $sb3, end-square: $sb2, adj-direction: $fromBlack) isa adjacency;
    (start-square: $sb4, end-square: $sb3, adj-direction: $fromBlack) isa adjacency;
    (start-square: $sc2, end-square: $sc1, adj-direction: $fromBlack) isa adjacency;
    (start-square: $sc3, end-square: $sc2, adj-direction: $fromBlack) isa adjacency;
    (start-square: $sc4, end-square: $sc3, adj-direction: $fromBlack) isa adjacency;
    (start-square: $sd2, end-square: $sd1, adj-direction: $fromBlack) isa adjacency;
    (start-square: $sd3, end-square: $sd2, adj-direction: $fromBlack) isa adjacency;
    (start-square: $sd4, end-square: $sd3, adj-direction: $fromBlack) isa adjacency;


    (start-square: $sa1, end-square: $sb1, adj-direction: $right) isa adjacency;
    (start-square: $sa2, end-square: $sb2, adj-direction: $right) isa adjacency;
    (start-square: $sa3, end-square: $sb3, adj-direction: $right) isa adjacency;
    (start-square: $sa4, end-square: $sb4, adj-direction: $right) isa adjacency;
    (start-square: $sb1, end-square: $sc1, adj-direction: $right) isa adjacency;
    (start-square: $sb2, end-square: $sc2, adj-direction: $right) isa adjacency;
    (start-square: $sb3, end-square: $sc3, adj-direction: $right) isa adjacency;
    (start-square: $sb4, end-square: $sc4, adj-direction: $right) isa adjacency;
    (start-square: $sc1, end-square: $sd1, adj-direction: $right) isa adjacency;
    (start-square: $sc2, end-square: $sd2, adj-direction: $right) isa adjacency;
    (start-square: $sc3, end-square: $sd3, adj-direction: $right) isa adjacency;
    (start-square: $sc4, end-square: $sd4, adj-direction: $right) isa adjacency;


    (start-square: $sb1, end-square: $sa1, adj-direction: $left) isa adjacency;
    (start-square: $sb2, end-square: $sa2, adj-direction: $left) isa adjacency;
    (start-square: $sb3, end-square: $sa3, adj-direction: $left) isa adjacency;
    (start-square: $sb4, end-square: $sa4, adj-direction: $left) isa adjacency;
    (start-square: $sc1, end-square: $sb1, adj-direction: $left) isa adjacency;
    (start-square: $sc2, end-square: $sb2, adj-direction: $left) isa adjacency;
    (start-square: $sc3, end-square: $sb3, adj-direction: $left) isa adjacency;
    (start-square: $sc4, end-square: $sb4, adj-direction: $left) isa adjacency;
    (start-square: $sd1, end-square: $sc1, adj-direction: $left) isa adjacency;
    (start-square: $sd2, end-square: $sc2, adj-direction: $left) isa adjacency;
    (start-square: $sd3, end-square: $sc3, adj-direction: $left) isa adjacency;
    (start-square: $sd4, end-square: $sc4, adj-direction: $left) isa adjacency;

    $whiteRook isa rook, has colour "white";
    $whitePawn isa pawn, has colour "white";
    $blackBishop isa bishop, has colour "black";
    $blackQueen isa queen, has colour "black";
    $whiteKnight isa knight, has colour "white"; 

    (positioned: $whitePawn, position: $sb3) isa positioning;
    (positioned: $whiteRook, position: $sb1) isa positioning;
    (positioned: $blackBishop, position: $sc4) isa positioning;
    (positioned: $blackQueen, position: $sc2) isa positioning;
    (positioned: $whiteKnight, position: $sd2) isa positioning;
    


    # 4 |   |   |bB |   |
    # 3 |   |wP |   |   |
    # 2 |   |   |bQ |wKn|
    # 1 |   |wR |   |   |
    #     A   B   C   D

    # match $p isa piece; $a isa square, has coor $from; $b isa square, has coor $to; (mover: $r, origin: $a, destination: $b) isa legal-move; get $from, $to;